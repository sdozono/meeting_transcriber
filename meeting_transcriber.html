<!DOCTYPE html>
<html lang="ja">
<head>
    <script>
        // é‡è¦ï¼šã“ã®APIã‚­ãƒ¼ã¯ã‚µãƒ³ãƒ—ãƒ«ã§ã™ã€‚å¿…ãšã”è‡ªèº«ã®OpenAI APIã‚­ãƒ¼ã«ç½®ãæ›ãˆã¦ãã ã•ã„ã€‚
    	const sessionApiKey = 'sk-xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx';
    </script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Webä¼šè­° ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ãƒ»ãƒ•ã‚¡ã‚¤ãƒ«æ–‡å­—èµ·ã“ã—ãƒ„ãƒ¼ãƒ«</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', 'Noto Sans JP', sans-serif;
        }
        .status-dot {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 8px;
        }
        #pushToTalkButton:active {
            transform: scale(0.95);
            background-color: #1e40af; /* A darker blue */
        }
        html, body {
            height: 100%;
            overflow: hidden;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">
    <div class="flex h-screen">
        <div class="w-1/3 bg-white p-6 overflow-y-auto flex flex-col space-y-6">
            <header class="text-center">
                <h1 class="text-2xl font-bold text-gray-900">Webä¼šè­° æ–‡å­—èµ·ã“ã—</h1>
                <p class="mt-1 text-sm text-gray-600">è¨­å®šã¨æ“ä½œ</p>
            </header>

            <div class="space-y-4 border-b pb-6">
                <h2 class="text-lg font-semibold text-gray-800">ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æ–‡å­—èµ·ã“ã—</h2>

                <div>
                    <label for="languageSelect" class="block text-sm font-medium text-gray-700 mb-1">æ–‡å­—èµ·ã“ã—è¨€èª</label>
                    <select id="languageSelect" class="w-full px-3 py-2 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-indigo-500 bg-white disabled:bg-gray-200">
                        <option value="ja" selected>æ—¥æœ¬èª</option>
                        <option value="en">è‹±èª</option>
                        <option value="zh">ä¸­å›½èª</option>
                        <option value="es">ã‚¹ãƒšã‚¤ãƒ³èª</option>
                        <option value="fr">ãƒ•ãƒ©ãƒ³ã‚¹èª</option>
                        <option value="de">ãƒ‰ã‚¤ãƒ„èª</option>
                        <option value="ko">éŸ“å›½èª</option>
                        <option value="af">ã‚¢ãƒ•ãƒªã‚«ãƒ¼ãƒ³ã‚¹èª</option>
                        <option value="ar">ã‚¢ãƒ©ãƒ“ã‚¢èª</option>
                        <option value="hy">ã‚¢ãƒ«ãƒ¡ãƒ‹ã‚¢èª</option>
                        <option value="az">ã‚¢ã‚¼ãƒ«ãƒã‚¤ã‚¸ãƒ£ãƒ³èª</option>
                        <option value="be">ãƒ™ãƒ©ãƒ«ãƒ¼ã‚·èª</option>
                        <option value="bs">ãƒœã‚¹ãƒ‹ã‚¢èª</option>
                        <option value="bg">ãƒ–ãƒ«ã‚¬ãƒªã‚¢èª</option>
                        <option value="ca">ã‚«ã‚¿ãƒ­ãƒ‹ã‚¢èª</option>
                        <option value="hr">ã‚¯ãƒ­ã‚¢ãƒã‚¢èª</option>
                        <option value="cs">ãƒã‚§ã‚³èª</option>
                        <option value="da">ãƒ‡ãƒ³ãƒãƒ¼ã‚¯èª</option>
                        <option value="nl">ã‚ªãƒ©ãƒ³ãƒ€èª</option>
                        <option value="et">ã‚¨ã‚¹ãƒˆãƒ‹ã‚¢èª</option>
                        <option value="fi">ãƒ•ã‚£ãƒ³ãƒ©ãƒ³ãƒ‰èª</option>
                        <option value="gl">ã‚¬ãƒªã‚·ã‚¢èª</option>
                        <option value="el">ã‚®ãƒªã‚·ãƒ£èª</option>
                        <option value="he">ãƒ˜ãƒ–ãƒ©ã‚¤èª</option>
                        <option value="hi">ãƒ’ãƒ³ãƒ‡ã‚£ãƒ¼èª</option>
                        <option value="hu">ãƒãƒ³ã‚¬ãƒªãƒ¼èª</option>
                        <option value="is">ã‚¢ã‚¤ã‚¹ãƒ©ãƒ³ãƒ‰èª</option>
                        <option value="id">ã‚¤ãƒ³ãƒ‰ãƒã‚·ã‚¢èª</option>
                        <option value="it">ã‚¤ã‚¿ãƒªã‚¢èª</option>
                        <option value="kn">ã‚«ãƒ³ãƒŠãƒ€èª</option>
                        <option value="kk">ã‚«ã‚¶ãƒ•èª</option>
                        <option value="lv">ãƒ©ãƒˆãƒ“ã‚¢èª</option>
                        <option value="lt">ãƒªãƒˆã‚¢ãƒ‹ã‚¢èª</option>
                        <option value="mk">ãƒã‚±ãƒ‰ãƒ‹ã‚¢èª</option>
                        <option value="ms">ãƒãƒ¬ãƒ¼èª</option>
                        <option value="mr">ãƒãƒ©ãƒ¼ãƒ†ã‚£ãƒ¼èª</option>
                        <option value="mi">ãƒã‚ªãƒªèª</option>
                        <option value="ne">ãƒãƒ‘ãƒ¼ãƒ«èª</option>
                        <option value="no">ãƒãƒ«ã‚¦ã‚§ãƒ¼èª</option>
                        <option value="fa">ãƒšãƒ«ã‚·ãƒ£èª</option>
                        <option value="pl">ãƒãƒ¼ãƒ©ãƒ³ãƒ‰èª</option>
                        <option value="pt">ãƒãƒ«ãƒˆã‚¬ãƒ«èª</option>
                        <option value="ro">ãƒ«ãƒ¼ãƒãƒ‹ã‚¢èª</option>
                        <option value="ru">ãƒ­ã‚·ã‚¢èª</option>
                        <option value="sr">ã‚»ãƒ«ãƒ“ã‚¢èª</option>
                        <option value="sk">ã‚¹ãƒ­ãƒã‚­ã‚¢èª</option>
                        <option value="sl">ã‚¹ãƒ­ãƒ™ãƒ‹ã‚¢èª</option>
                        <option value="sw">ã‚¹ãƒ¯ãƒ’ãƒªèª</option>
                        <option value="sv">ã‚¹ã‚¦ã‚§ãƒ¼ãƒ‡ãƒ³èª</option>
                        <option value="tl">ã‚¿ã‚¬ãƒ­ã‚°èª</option>
                        <option value="ta">ã‚¿ãƒŸãƒ«èª</option>
                        <option value="th">ã‚¿ã‚¤èª</option>
                        <option value="tr">ãƒˆãƒ«ã‚³èª</option>
                        <option value="uk">ã‚¦ã‚¯ãƒ©ã‚¤ãƒŠèª</option>
                        <option value="ur">ã‚¦ãƒ«ãƒ‰ã‚¥ãƒ¼èª</option>
                        <option value="vi">ãƒ™ãƒˆãƒŠãƒ èª</option>
                        <option value="cy">ã‚¦ã‚§ãƒ¼ãƒ«ã‚ºèª</option>
                    </select>
                </div>
                <div>
                    <label for="intervalSelect" class="block text-sm font-medium text-gray-700 mb-1">éŒ²éŸ³é–“éš”ï¼ˆç§’ï¼‰</label>
                    <select id="intervalSelect" class="w-full px-3 py-2 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-indigo-500 bg-white disabled:bg-gray-200">
                        <option value="3">3ç§’ï¼ˆãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æ€§é‡è¦–ï¼‰</option>
                        <option value="4" selected>4ç§’ï¼ˆãƒãƒ©ãƒ³ã‚¹ï¼‰</option>
                        <option value="10">10ç§’ï¼ˆç²¾åº¦é‡è¦–ï¼‰</option>
                        <option value="15">15ç§’ï¼ˆé«˜ç²¾åº¦ï¼‰</option>
                        <option value="20">20ç§’ï¼ˆæœ€é«˜ç²¾åº¦ï¼‰</option>
                    </select>
                </div>
                <div>
                    <label for="micModeSelect" class="block text-sm font-medium text-gray-700 mb-1">ãƒã‚¤ã‚¯ãƒ¢ãƒ¼ãƒ‰</label>
                    <select id="micModeSelect" class="w-full px-3 py-2 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-indigo-500 bg-white disabled:bg-gray-200">
                        <option value="off">ã‚ªãƒ•</option>
                        <option value="always_on">å¸¸æ™‚ã‚ªãƒ³</option>
                        <option value="push_to_talk">ãƒ—ãƒƒã‚·ãƒ¥ãƒˆã‚¥ãƒˆãƒ¼ã‚¯</option>
                    </select>
                </div>

                <div class="flex items-center pt-2">
                    <input id="translationCheckbox" type="checkbox" class="h-4 w-4 text-indigo-600 focus:ring-indigo-500 border-gray-300 rounded disabled:bg-gray-300">
                    <label for="translationCheckbox" id="translationLabel" class="ml-2 block text-sm text-gray-900">æ—¥æœ¬èªã¸ç¿»è¨³ã™ã‚‹</label>
                </div>

                <div id="pushToTalkContainer" class="hidden text-center">
                    <button id="pushToTalkButton" class="w-full px-6 py-3 bg-blue-800 text-white font-semibold rounded-lg shadow-md transition-all duration-150 ease-in-out disabled:bg-gray-400 disabled:cursor-not-allowed">
                        æŠ¼ã—ã¦è©±ã™ ğŸ™ï¸
                    </button>
                    <p id="micStatus" class="text-xs text-gray-500 mt-2"></p>
                </div>
                <div class="grid grid-cols-2 gap-4">
                    <button id="startButton" class="w-full px-6 py-3 bg-blue-600 text-white font-semibold rounded-lg shadow-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-75 transition-all transform hover:scale-105 disabled:bg-gray-400 disabled:cursor-not-allowed disabled:transform-none">
                        é–‹å§‹
                    </button>
                    <button id="stopButton" disabled class="w-full px-6 py-3 bg-red-600 text-white font-semibold rounded-lg shadow-md hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-opacity-75 transition-all disabled:bg-gray-400 disabled:cursor-not-allowed">
                        åœæ­¢
                    </button>
                </div>
            </div>

            <div class="space-y-4 border-b pb-6">
                <h2 class="text-lg font-semibold text-gray-800">ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰æ–‡å­—èµ·ã“ã—</h2>
                 <div>
                    <label for="audioFileInput" class="block text-sm font-medium text-gray-700 mb-1">éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠ (.mp3, .wav)</label>
                    <input type="file" id="audioFileInput" accept=".mp3,.wav" class="w-full text-sm text-gray-500
                        file:mr-4 file:py-2 file:px-4
                        file:rounded-full file:border-0
                        file:text-sm file:font-semibold
                        file:bg-blue-50 file:text-blue-700
                        hover:file:bg-blue-100
                    "/>
                </div>
                <button id="transcribeFileButton" class="w-full px-6 py-3 bg-indigo-600 text-white font-semibold rounded-lg shadow-md hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-opacity-75 transition-all disabled:bg-gray-400 disabled:cursor-not-allowed">
                    ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ–‡å­—èµ·ã“ã—
                </button>
            </div>
            <div id="status" class="flex items-center justify-center text-gray-600 py-2">
                <span class="status-dot bg-gray-400"></span>
                <span>å¾…æ©Ÿä¸­</span>
            </div>

            <div class="border-t pt-6 space-y-4">
                <div class="text-center">
                    <button id="summarizeButton" disabled class="w-full px-6 py-3 bg-green-600 text-white font-semibold rounded-lg shadow-md hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-opacity-75 transition-all disabled:bg-gray-400 disabled:cursor-not-allowed">
                        ã“ã®å†…å®¹ã‚’è¦ç´„ã™ã‚‹ âœ¨
                    </button>
                </div>
                <div id="summaryContainer" class="hidden">
                    <h2 class="text-lg font-bold text-gray-800 mb-2">ä¼šè­°ã®è¦ç´„</h2>
                    <div id="summaryResult" class="w-full p-3 border border-gray-200 rounded-lg bg-gray-50 min-h-[100px] whitespace-pre-wrap text-sm"></div>
                </div>
            </div>
        </div>

        <div class="w-2/3 p-6 flex flex-col bg-gray-100">
            <h2 class="text-2xl font-bold text-gray-800 mb-4 flex-shrink-0">æ–‡å­—èµ·ã“ã—çµæœ</h2>
            <div id="transcriptContainer" class="flex-grow bg-white p-4 border rounded-lg overflow-y-auto shadow-inner">
                <p id="transcript" class="text-gray-800 whitespace-pre-wrap"></p>
            </div>
        </div>
    </div>

<script>
    const startButton = document.getElementById('startButton');
    const stopButton = document.getElementById('stopButton');
    const statusDiv = document.getElementById('status');
    const transcriptContainer = document.getElementById('transcriptContainer');
    const transcriptDiv = document.getElementById('transcript');
    const intervalSelect = document.getElementById('intervalSelect');
    const languageSelect = document.getElementById('languageSelect');
    const micModeSelect = document.getElementById('micModeSelect');
    const translationCheckbox = document.getElementById('translationCheckbox');
    const translationLabel = document.getElementById('translationLabel');
    const pushToTalkContainer = document.getElementById('pushToTalkContainer');
    const pushToTalkButton = document.getElementById('pushToTalkButton');
    const micStatus = document.getElementById('micStatus');
    const summarizeButton = document.getElementById('summarizeButton');
    const summaryContainer = document.getElementById('summaryContainer');
    const summaryResult = document.getElementById('summaryResult');
    const audioFileInput = document.getElementById('audioFileInput');
    const transcribeFileButton = document.getElementById('transcribeFileButton');

    let stream;
    let recordingMimeType = '';
    let isRecording = false; 
    let recordingInterval = 4000; 
    let isPushToTalkMouseDown = false; 

    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    let recognition;
    
    // â˜…â˜…â˜… å¤‰æ›´ç‚¹ â˜…â˜…â˜…
    // ç„¡éŸ³ã¨åˆ¤å®šã™ã‚‹éŸ³é‡ã®ã—ãã„å€¤ã€‚0.01ã¯ã‹ãªã‚Šé™ã‹ãªãƒ¬ãƒ™ãƒ«ã‚’æ„å‘³ã—ã¾ã™ã€‚
    const SILENCE_THRESHOLD = 0.01;
    
    const langToBcp47 = {
        'af': 'af-ZA', 'ar': 'ar-SA', 'hy': 'hy-AM', 'az': 'az-AZ', 'be': 'be-BY', 'bs': 'bs-BA',
        'bg': 'bg-BG', 'ca': 'ca-ES', 'zh': 'cmn-Hans-CN', 'hr': 'hr-HR', 'cs': 'cs-CZ', 'da': 'da-DK',
        'nl': 'nl-NL', 'en': 'en-US', 'et': 'et-EE', 'fi': 'fi-FI', 'fr': 'fr-FR', 'gl': 'gl-ES',
        'de': 'de-DE', 'el': 'el-GR', 'he': 'he-IL', 'hi': 'hi-IN', 'hu': 'hu-HU', 'is': 'is-IS',
        'id': 'id-ID', 'it': 'it-IT', 'ja': 'ja-JP', 'kn': 'kn-IN', 'kk': 'kk-KZ', 'ko': 'ko-KR',
        'lv': 'lv-LV', 'lt': 'lt-LT', 'mk': 'mk-MK', 'ms': 'ms-MY', 'mr': 'mr-IN', 'mi': 'mi-NZ',
        'ne': 'ne-NP', 'no': 'no-NO', 'fa': 'fa-IR', 'pl': 'pl-PL', 'pt': 'pt-BR', 'ro': 'ro-RO',
        'ru': 'ru-RU', 'sr': 'sr-RS', 'sk': 'sk-SK', 'sl': 'sl-SI', 'es': 'es-ES', 'sw': 'sw-TZ',
        'sv': 'sv-SE', 'tl': 'tl-PH', 'ta': 'ta-IN', 'th': 'th-TH', 'tr': 'tr-TR', 'uk': 'uk-UA',
        'ur': 'ur-PK', 'vi': 'vi-VN', 'cy': 'cy-GB'
    };
    
    // --- Core Functions ---

    // â˜…â˜…â˜… æ–°è¦è¿½åŠ  â˜…â˜…â˜…
    // éŸ³å£°ãƒ‡ãƒ¼ã‚¿(Blob)ã‚’å—ã‘å–ã‚Šã€ç„¡éŸ³ã‹ã©ã†ã‹ã‚’åˆ¤å®šã™ã‚‹éåŒæœŸé–¢æ•°
    async function isSilent(blob) {
        // AudioContextãŒä½¿ãˆãªã„ãƒ–ãƒ©ã‚¦ã‚¶ã§ã¯åˆ¤å®šã‚’ã‚¹ã‚­ãƒƒãƒ—
        if (!window.AudioContext && !window.webkitAudioContext) {
            console.warn("Web Audio API is not supported. Skipping silence detection.");
            return false;
        }
        // AudioContextã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ä½œæˆ
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        try {
            // Blobã‚’ArrayBufferã«å¤‰æ›
            const arrayBuffer = await blob.arrayBuffer();
            // ãƒ‡ãƒ¼ã‚¿ãŒæ¥µç«¯ã«å°ã•ã„å ´åˆã¯ç„¡éŸ³ã¨ã¿ãªã™
            if (arrayBuffer.byteLength < 1024) return true; 
            // ArrayBufferã‚’ãƒ‡ã‚³ãƒ¼ãƒ‰ã—ã¦éŸ³å£°ãƒ‡ãƒ¼ã‚¿(AudioBuffer)ã«å¤‰æ›
            const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
            // æœ€åˆã®ãƒãƒ£ãƒ³ãƒãƒ«ã®PCMãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
            const pcmData = audioBuffer.getChannelData(0);
            
            let sumOfSquares = 0.0;
            for (let i = 0; i < pcmData.length; i++) {
                sumOfSquares += pcmData[i] * pcmData[i];
            }
            // RMSï¼ˆäºŒä¹—å¹³å‡å¹³æ–¹æ ¹ï¼‰ã‚’è¨ˆç®—ã—ã¦ã€éŸ³é‡ã®å¤§ãã•ã‚’ç®—å‡º
            const rms = Math.sqrt(sumOfSquares / pcmData.length);
            
            console.log(`Audio level (RMS): ${rms}`); // ãƒ‡ãƒãƒƒã‚°ç”¨ã«éŸ³é‡ã‚’ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã«è¡¨ç¤º
            
            // è¨ˆç®—ã—ãŸéŸ³é‡ãŒã—ãã„å€¤ã‚ˆã‚Šå°ã•ã„ã‹åˆ¤å®š
            return rms < SILENCE_THRESHOLD;

        } catch (e) {
            console.error("Error during silence detection:", e);
            // ãƒ‡ã‚³ãƒ¼ãƒ‰ã‚¨ãƒ©ãƒ¼ãªã©ãŒèµ·ããŸå ´åˆã¯ã€å¿µã®ãŸã‚éŸ³å£°ã‚ã‚Šã¨åˆ¤æ–­ã—ã¦å‡¦ç†ã‚’ç¶šè¡Œ
            return false;
        } finally {
            // AudioContextã‚’é–‰ã˜ã¦ãƒªã‚½ãƒ¼ã‚¹ã‚’è§£æ”¾
            if (audioContext.state !== 'closed') {
                await audioContext.close();
            }
        }
    }


    async function checkBrowser() {
        if (navigator.brave && await navigator.brave.isBrave()) {
            alert('ç¾åœ¨Braveãƒ–ãƒ©ã‚¦ã‚¶ã§ã”è¦§ã«ãªã£ã¦ã„ã¾ã™ã€‚ãƒã‚¤ã‚¯æ©Ÿèƒ½ãªã©ã€ä¸€éƒ¨ã®æ©Ÿèƒ½ãŒBraveã®ãƒ—ãƒ©ã‚¤ãƒã‚·ãƒ¼ä¿è­·æ©Ÿèƒ½ï¼ˆShieldsï¼‰ã«ã‚ˆã£ã¦åˆ¶é™ã•ã‚Œã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚\n\næœ€é©ãªä½“é¨“ã®ãŸã‚ã«ã€Chrome/Edge/Safariã¸ã®åˆ‡ã‚Šæ›¿ãˆã‚’æ¨å¥¨ã—ã¾ã™ã€‚');
            return; 
        }
        const userAgent = navigator.userAgent;
        if (!userAgent.includes("Chrome") && !userAgent.includes("Edg") && !userAgent.includes("Safari") || userAgent.includes("Brave")) {
            alert('è­¦å‘Š: ã“ã®ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã¯ã€Chrome, Edge, Safariã§ã®åˆ©ç”¨ã«æœ€é©åŒ–ã•ã‚Œã¦ã„ã¾ã™ã€‚ãŠä½¿ã„ã®ãƒ–ãƒ©ã‚¦ã‚¶ã§ã¯ã€ä¸€éƒ¨æ©Ÿèƒ½ãŒæ­£å¸¸ã«å‹•ä½œã—ãªã„å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚');
        }
    }
    
    function scrollToBottom() {
        transcriptContainer.scrollTop = transcriptContainer.scrollHeight;
    }

    function updateStatus(text, color) {
        statusDiv.innerHTML = `<span class="status-dot bg-${color}-500"></span><span>${text}</span>`;
    }
    
    function createTimestamp() {
        const now = new Date();
        const year = now.getFullYear();
        const month = String(now.getMonth() + 1).padStart(2, '0');
        const day = String(now.getDate()).padStart(2, '0');
        const hours = String(now.getHours()).padStart(2, '0');
        const minutes = String(now.getMinutes()).padStart(2, '0');
        const seconds = String(now.getSeconds()).padStart(2, '0');
        return `${year}/${month}/${day} ${hours}:${minutes}:${seconds}`;
    }

    function setupSpeechRecognition() {
        if (!SpeechRecognition) {
            micModeSelect.disabled = true;
            micModeSelect.innerHTML = '<option>ãŠä½¿ã„ã®ãƒ–ãƒ©ã‚¦ã‚¶ã¯éå¯¾å¿œã§ã™</option>';
            return;
        }
        recognition = new SpeechRecognition();
        const selectedLangCode = languageSelect.value;
        recognition.lang = langToBcp47[selectedLangCode] || selectedLangCode;
        recognition.interimResults = true;
        recognition.continuous = true;
        recognition.onstart = () => micStatus.textContent = 'ãƒã‚¤ã‚¯ã‚’èªè­˜ä¸­ã§ã™...';
        
        recognition.onresult = async (event) => {
            let finalTranscript = '';
            for (let i = event.resultIndex; i < event.results.length; i++) {
                if (event.results[i].isFinal) finalTranscript += event.results[i][0].transcript;
            }
            
            if (finalTranscript) {
                const transcriptText = finalTranscript.trim();
                const originalTextLine = `[ãƒã‚¤ã‚¯]: ${transcriptText}\n`;
                transcriptDiv.textContent += originalTextLine;
                scrollToBottom();

                if (translationCheckbox.checked && languageSelect.value !== 'ja') {
                    const translatedText = await translateToJapanese(transcriptText);
                    const translatedTextLine = `  â”” (è¨³): ${translatedText.trim()}\n`;
                    transcriptDiv.textContent += translatedTextLine;
                    scrollToBottom();
                }
            }
        };

        recognition.onerror = (event) => {
            console.error('Speech Recognition Error', event);
            micStatus.textContent = `ãƒã‚¤ã‚¯ã‚¨ãƒ©ãƒ¼: ${event.error}`;
            isPushToTalkMouseDown = false;
        };
        recognition.onend = () => {
            if (isPushToTalkMouseDown) {
                try { recognition.start(); } catch(e) { console.error("Could not restart recognition", e); micStatus.textContent = ''; isPushToTalkMouseDown = false; }
                return; 
            }
            if (isRecording && micModeSelect.value === 'always_on') {
                micStatus.textContent = 'ãƒã‚¤ã‚¯æ¥ç¶šãŒåˆ‡ã‚Œã¾ã—ãŸã€‚1ç§’å¾Œã«å†æ¥ç¶šã—ã¾ã™ã€‚';
                setTimeout(() => {
                    if (isRecording && micModeSelect.value === 'always_on') {
                        try { micStatus.textContent = 'ãƒã‚¤ã‚¯ã‚’å†èµ·å‹•ã—ã¦ã„ã¾ã™...'; recognition.start(); } catch(e) { console.error("Could not restart recognition", e); }
                    }
                }, 1000);
            } else {
                 micStatus.textContent = '';
            }
        };
    }
    
    function updateMicControls() {
        const selectedMode = micModeSelect.value;
        pushToTalkContainer.classList.toggle('hidden', selectedMode !== 'push_to_talk');
        pushToTalkButton.disabled = selectedMode !== 'push_to_talk';
        if(selectedMode === 'off' && recognition) {
            isPushToTalkMouseDown = false;
            recognition.stop();
        }
    }

    function updateTranslationCheckboxState() {
        const isJapanese = languageSelect.value === 'ja';
        translationCheckbox.disabled = isJapanese;
        translationLabel.classList.toggle('text-gray-400', isJapanese);
        if (isJapanese) {
            translationCheckbox.checked = false;
        }
    }

    (async () => {
        await checkBrowser();
        setupSpeechRecognition();
        updateMicControls();
        updateTranslationCheckboxState();
    })();

    async function startTranscription() {
        if (isRecording) return;
        if (!sessionApiKey.startsWith('sk-')) {
            alert('APIã‚­ãƒ¼ãŒã‚³ãƒ¼ãƒ‰ã«è¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚sessionApiKeyå¤‰æ•°ã‚’ã‚ãªãŸã®ã‚­ãƒ¼ã«ç½®ãæ›ãˆã¦ãã ã•ã„ã€‚');
            return;
        }
        recordingInterval = parseInt(intervalSelect.value, 10) * 1000;
        updateStatus('ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«è¨±å¯ã‚’æ±‚ã‚ã¦ã„ã¾ã™...', 'yellow');
        try {
            stream = await navigator.mediaDevices.getDisplayMedia({ video: true, audio: { channelCount: 1, sampleRate: 16000 } });
            if (stream.getAudioTracks().length === 0) {
                updateStatus('ã‚¨ãƒ©ãƒ¼: éŸ³å£°ãƒˆãƒ©ãƒƒã‚¯ãŒå–å¾—ã§ãã¾ã›ã‚“ã§ã—ãŸã€‚', 'red');
                stream.getTracks().forEach(track => track.stop());
                return;
            }
            recordingMimeType = ['audio/webm;codecs=opus', 'audio/webm', 'audio/mp4'].find(type => MediaRecorder.isTypeSupported(type));
            if (!recordingMimeType) {
                updateStatus('ã‚¨ãƒ©ãƒ¼: å¯¾å¿œã™ã‚‹éŸ³å£°å½¢å¼ã‚’éŒ²éŸ³ã§ãã¾ã›ã‚“ã€‚', 'red');
                stream.getTracks().forEach(track => track.stop());
                return;
            }
            isRecording = true;
            transcriptDiv.textContent = `--- æ–‡å­—èµ·ã“ã—é–‹å§‹: ${createTimestamp()} ---\n\n`;
            summaryContainer.classList.add('hidden');
            summaryResult.textContent = '';
            [startButton, intervalSelect, languageSelect, micModeSelect, transcribeFileButton, translationCheckbox].forEach(el => el.disabled = true);
            stopButton.disabled = false;
            summarizeButton.disabled = true;
            if (micModeSelect.value === 'always_on' && recognition) {
                try { recognition.start(); } catch(e) { console.error(e); }
            }
            processChunk(new MediaStream(stream.getAudioTracks()));
        } catch (error) {
            console.error('Error starting transcription:', error);
            updateStatus(`ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'red');
            isRecording = false;
            [startButton, intervalSelect, languageSelect, micModeSelect, transcribeFileButton].forEach(el => el.disabled = false);
            updateTranslationCheckboxState();
            updateMicControls();
        }
    }

    function stopTranscription() {
        isRecording = false; 
        isPushToTalkMouseDown = false; 
        if (recognition) recognition.stop();
        [stopButton, summarizeButton].forEach(el => el.disabled = true);
        [startButton, intervalSelect, languageSelect, micModeSelect, transcribeFileButton].forEach(el => el.disabled = false);
        updateTranslationCheckboxState();
        if (transcriptDiv.textContent.trim().length > 0) summarizeButton.disabled = false;
        updateMicControls();
        updateStatus('åœæ­¢å‡¦ç†ä¸­...', 'yellow');
    }

    async function processChunk(audioStream) {
        if (!isRecording) {
            if (stream) stream.getTracks().forEach(track => track.stop());
            updateStatus('åœæ­¢ã—ã¾ã—ãŸ', 'gray');
            return;
        }
        const recorder = new MediaRecorder(audioStream, { mimeType: recordingMimeType });
        const chunks = [];
        recorder.ondataavailable = (e) => e.data.size > 0 && chunks.push(e.data);
        
        // â˜…â˜…â˜… å¤‰æ›´ç‚¹ â˜…â˜…â˜…
        // éŒ²éŸ³ãŒåœæ­¢ã—ãŸã‚¿ã‚¤ãƒŸãƒ³ã‚°ã§ç„¡éŸ³åˆ¤å®šã‚’å®Ÿè¡Œ
        recorder.onstop = async () => {
            if (chunks.length > 0) {
                const audioBlob = new Blob(chunks, { type: recordingMimeType });
                
                // ç„¡éŸ³åˆ¤å®šã‚’å‘¼ã³å‡ºã™
                if (await isSilent(audioBlob)) {
                    console.log("Silent chunk detected, skipping API call.");
                    // ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«çŠ¶æ³ã‚’çŸ¥ã‚‰ã›ã‚‹ï¼ˆä»»æ„ï¼‰
                    updateStatus('ç„¡éŸ³åŒºé–“ã‚’ã‚¹ã‚­ãƒƒãƒ—ã—ã¾ã—ãŸ', 'gray');
                } else {
                    // éŸ³å£°ãŒã‚ã‚‹å ´åˆã®ã¿APIã«é€ä¿¡
                    await sendToOpenAI(audioBlob, '[ã‚·ã‚¹ãƒ†ãƒ ]');
                }
            }
            // éŒ²éŸ³ãŒç¶™ç¶šä¸­ãªã‚‰ã€æ¬¡ã®éŒ²éŸ³ãƒ—ãƒ­ã‚»ã‚¹ã‚’é–‹å§‹
            if (isRecording) {
                processChunk(new MediaStream(stream.getAudioTracks()));
            } else {
                if (stream) stream.getTracks().forEach(track => track.stop());
                updateStatus('åœæ­¢ã—ã¾ã—ãŸ', 'gray');
            }
        };

        updateStatus(`${recordingInterval / 1000}ç§’é–“éŒ²éŸ³ä¸­...`, 'green');
        recorder.start();
        setTimeout(() => { if (recorder.state === 'recording') recorder.stop(); }, recordingInterval);
    }

    async function translateToJapanese(text) {
        if (!sessionApiKey.startsWith('sk-')) return "[ç¿»è¨³ã‚¨ãƒ©ãƒ¼: APIã‚­ãƒ¼ãŒæœªè¨­å®šã§ã™]";
        try {
            const response = await fetch('https://api.openai.com/v1/chat/completions', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${sessionApiKey}` },
                body: JSON.stringify({
                    model: 'gpt-3.5-turbo',
                    messages: [
                        { role: 'system', content: 'ã‚ãªãŸã¯ãƒ—ãƒ­ã®ç¿»è¨³å®¶ã§ã™ã€‚ä»¥ä¸‹ã®ãƒ†ã‚­ã‚¹ãƒˆã‚’è‡ªç„¶ã§åˆ†ã‹ã‚Šã‚„ã™ã„æ—¥æœ¬èªã«ç¿»è¨³ã—ã¦ãã ã•ã„ã€‚' },
                        { role: 'user', content: text }
                    ],
                    temperature: 0.2,
                })
            });
            const result = await response.json();
            if (response.ok) {
                return result.choices[0].message.content;
            } else {
                throw new Error(result.error ? result.error.message : 'Unknown API error');
            }
        } catch (error) {
            console.error('Translation Error:', error);
            return `[ç¿»è¨³ã‚¨ãƒ©ãƒ¼: ${error.message}]`;
        }
    }

    async function sendToOpenAI(audioData, prefix) {
        if (!sessionApiKey.startsWith('sk-')) {
            updateStatus('APIã‚­ãƒ¼ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚å‡¦ç†ã‚’åœæ­¢ã—ã¾ã—ãŸã€‚', 'red');
            if (isRecording) stopTranscription();
            return;
        }
        updateStatus('éŸ³å£°ãƒ‡ãƒ¼ã‚¿ã‚’è»¢é€ãƒ»è§£æä¸­...', 'yellow');
        const formData = new FormData();
        const fileExtension = (audioData.type) ? audioData.type.split('/')[1].split(';')[0] : 'mp3';
        formData.append('file', audioData, `audio.${fileExtension}`);
        formData.append('model', 'whisper-1');
        formData.append('language', languageSelect.value);

        try {
            const response = await fetch('https://api.openai.com/v1/audio/transcriptions', {
                method: 'POST',
                headers: { 'Authorization': `Bearer ${sessionApiKey}` },
                body: formData
            });
            const result = await response.json();
            if (!response.ok) throw new Error(result.error ? result.error.message : 'Unknown API error');

            const transcriptText = result.text.replace(/ã”è¦–è´ã‚ã‚ŠãŒã¨ã†ã”ã–ã„ã¾ã—ãŸã€‚?/g, '').trim();

            if (transcriptText) {
                const originalTextLine = `${prefix}: ${transcriptText}\n`;
                transcriptDiv.textContent += originalTextLine;
                scrollToBottom();

                if (translationCheckbox.checked && languageSelect.value !== 'ja') {
                    updateStatus('æ—¥æœ¬èªã¸ç¿»è¨³ä¸­...', 'blue');
                    const translatedText = await translateToJapanese(transcriptText);
                    const translatedTextLine = `  â”” (è¨³): ${translatedText.trim()}\n`;
                    transcriptDiv.textContent += translatedTextLine;
                    scrollToBottom();
                }
            }
        } catch (error) {
            console.error('Error sending to OpenAI:', error);
            updateStatus(`APIã‚¨ãƒ©ãƒ¼: ${error.message}`, 'red');
            if(isRecording) stopTranscription();
        }
    }

    async function transcribeUploadedFile() {
        const file = audioFileInput.files[0];
        if (!file) { alert('ãƒ•ã‚¡ã‚¤ãƒ«ãŒé¸æŠã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚'); return; }
        if (!sessionApiKey.startsWith('sk-')) { alert('APIã‚­ãƒ¼ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚'); return; }
        
        [transcribeFileButton, startButton, languageSelect, translationCheckbox].forEach(el => el.disabled = true);
        transcribeFileButton.textContent = 'å‡¦ç†ä¸­...';
        summarizeButton.disabled = true;

        // â˜…â˜…â˜… å¤‰æ›´ç‚¹ â˜…â˜…â˜…
        // ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ–‡å­—èµ·ã“ã—ã™ã‚‹å‰ã«ç„¡éŸ³åˆ¤å®š
        updateStatus('ãƒ•ã‚¡ã‚¤ãƒ«ã®éŸ³å£°ã‚’åˆ†æä¸­...', 'blue');
        if (await isSilent(file)) {
            alert('é¸æŠã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«ã¯ç„¡éŸ³ã€ã¾ãŸã¯éŸ³å£°ãŒæ¤œå‡ºã•ã‚Œã¾ã›ã‚“ã§ã—ãŸã€‚å‡¦ç†ã‚’ä¸­æ–­ã—ã¾ã™ã€‚');
            // çŠ¶æ…‹ã‚’å…ƒã«æˆ»ã™
            [transcribeFileButton, startButton, languageSelect].forEach(el => el.disabled = false);
            updateTranslationCheckboxState();
            transcribeFileButton.textContent = 'ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ–‡å­—èµ·ã“ã—';
            audioFileInput.value = ''; // ãƒ•ã‚¡ã‚¤ãƒ«é¸æŠã‚’ãƒªã‚»ãƒƒãƒˆ
            updateStatus('å¾…æ©Ÿä¸­', 'gray');
            return; // ã“ã“ã§å‡¦ç†ã‚’çµ‚äº†
        }
        
        transcriptDiv.textContent = `--- ãƒ•ã‚¡ã‚¤ãƒ«æ–‡å­—èµ·ã“ã—é–‹å§‹: ${createTimestamp()} ---\n\n`;
        summaryContainer.classList.add('hidden');
        summaryResult.textContent = '';
        await sendToOpenAI(file, '[ãƒ•ã‚¡ã‚¤ãƒ«]');
        updateStatus('ãƒ•ã‚¡ã‚¤ãƒ«ã®æ–‡å­—èµ·ã“ã—ãŒå®Œäº†ã—ã¾ã—ãŸ', 'green');

        [transcribeFileButton, startButton, languageSelect].forEach(el => el.disabled = false);
        updateTranslationCheckboxState();
        transcribeFileButton.textContent = 'ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ–‡å­—èµ·ã“ã—';
        if (transcriptDiv.textContent.trim().length > 0) summarizeButton.disabled = false;
        audioFileInput.value = ''; 
    }

    async function summarizeTranscription() {
        const transcriptText = transcriptDiv.textContent;
        if (!transcriptText || transcriptText.trim().length < 50) { 
            alert('è¦ç´„ã™ã‚‹ã«ã¯ã€æ–‡å­—èµ·ã“ã—ã®å†…å®¹ãŒçŸ­ã™ãã¾ã™ã€‚'); return;
        }
        summarizeButton.disabled = true;
        summarizeButton.textContent = 'è¦ç´„ä¸­...';
        summaryContainer.classList.remove('hidden');
        summaryResult.textContent = 'AIãŒè¦ç´„ã‚’ä½œæˆã—ã¦ã„ã¾ã™...';
        try {
            const response = await fetch('https://api.openai.com/v1/chat/completions', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${sessionApiKey}` },
                body: JSON.stringify({
                    model: 'gpt-3.5-turbo',
                    messages: [
                        { role: 'system', content: 'ã‚ãªãŸã¯ã€ä¼šè­°ã®æ–‡å­—èµ·ã“ã—ã‚’è¦ç´„ã™ã‚‹å„ªç§€ãªã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆã§ã™ã€‚' },
                        { role: 'user', content: `ä»¥ä¸‹ã®ä¼šè­°ã®æ–‡å­—èµ·ã“ã—ã‚’ã€é‡è¦ãªãƒã‚¤ãƒ³ãƒˆã‚’ç®‡æ¡æ›¸ãã«ã—ã¦ç°¡æ½”ã«è¦ç´„ã—ã¦ãã ã•ã„ã€‚\n\n---\n\n${transcriptText}` }
                    ]
                })
            });
            const result = await response.json();
            if (!response.ok) throw new Error(result.error ? result.error.message : 'Unknown API error');
            summaryResult.textContent = result.choices[0].message.content;
        } catch (error) {
            console.error('Summarization Error:', error);
            summaryResult.textContent = `è¦ç´„ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: ${error.message}`;
        } finally {
            summarizeButton.disabled = false;
            summarizeButton.textContent = 'ã“ã®å†…å®¹ã‚’è¦ç´„ã™ã‚‹ âœ¨';
        }
    }

    // --- Event Listeners ---
    startButton.addEventListener('click', startTranscription);
    stopButton.addEventListener('click', stopTranscription);
    micModeSelect.addEventListener('change', updateMicControls);
    summarizeButton.addEventListener('click', summarizeTranscription);
    transcribeFileButton.addEventListener('click', transcribeUploadedFile);
    
    languageSelect.addEventListener('change', () => {
        if (recognition) {
            const selectedLangCode = languageSelect.value;
            recognition.lang = langToBcp47[selectedLangCode] || selectedLangCode;
        }
        updateTranslationCheckboxState();
    });
    
    pushToTalkButton.addEventListener('mousedown', () => {
        if (micModeSelect.value === 'push_to_talk' && recognition) {
            isPushToTalkMouseDown = true; 
            try { micStatus.textContent = 'ãƒã‚¤ã‚¯å…¥åŠ›ä¸­...'; recognition.start(); } catch (e) { if (e.name !== 'InvalidStateError') console.error("Recognition start error:", e); }
        }
    });
    pushToTalkButton.addEventListener('mouseup', () => {
        isPushToTalkMouseDown = false; 
        if (micModeSelect.value === 'push_to_talk' && recognition) try { recognition.stop(); } catch (e) { console.error("Recognition stop error:", e); }
    });
    pushToTalkButton.addEventListener('mouseleave', () => {
        if (isPushToTalkMouseDown) {
            isPushToTalkMouseDown = false;
            if (micModeSelect.value === 'push_to_talk' && recognition) try { recognition.stop(); } catch (e) { console.error("Recognition stop error:", e); }
        }
    });

</script>
</body>
</html>